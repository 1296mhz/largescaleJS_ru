<!-- ### Паттерн «Медиатор» -->

Объяснить, что из себя представляет паттерн «Медиатор» можно на примере простой
аналогии — представьте себе как аэропорт обеспечивает контроль траффика. Башня
принимает решение о том, какие самолеты могут приземлиться, потому что все
взаимодействие происходит от самолетов к контрольной башне, вместо того, чтобы
происходить напрямую между самолетами. Централизованный котроллер — это ключ к
успеху этой системы, и это и есть паттерн «медиатор».

Медиатор используется когда взаимодействия между модулями могут быть сложными,
но все еще **хорошо определенными**. Если оказывается, что система может может
иметь слишком много связай между модулями в коде, это может быть моментом, когда
следует создать центральную точку контроля. Медиатор идеально подходит для этой
задачи.

В реальном мире, термин «медиатор» **инкапсулирует взаимодействие** различных
модулей друг с другом, выступая в качестве посредника. Паттерн также способствует
ослаблению связей,  предотвращая взаимодействие модулей друг с другом. В нашей
системе это помогает решить проблемы с зависимостями между модулями.

Какие еще преимущества существуют у «медиатора»? Ну например, медиатор позволяет
каждому модулю действовать абсолютно независимо, таким образом модули выходят
очень гибкими. Если вы раньше использовали паттерн «Обсервер» (читатель/издатель),
для реализации системы доставки событий между модулями в вашей системе, то 
достаточно легко разберетесь с медиатором.

Давайте посмотрим на модель взаимодействия модулей и медиатора:

![][7]

Мы можем смотреть на модули как на «издателя» и «медиатор», либо как на «издателя»
и «читателя». Модуль1 отправляет событие, сообщающее медиатору о том, что что-то
нужно сделать. Медиатор получает событие и сообщает модулям о том, что нужно 
выполнять действия необходимые для завершения полученной задачи. Модуль2
выполняет задачу, которую требовал модуль 1, и отправляет сообщение об этом
медиатору. Во время этого, модуль3 тоже запускается медиатором для логгироваия
всех сообщений, передаваемых обратно от медиатора.

Обратите внимание, что здесь нет места прямому взаимодействию между модулями.
Если в модуле3 случится ошибка или он просто перестанет работать, то медатор,
гипотетически, может приостановить выполнение задач в других модулях,
перезапустить модуль3 и затем продолжить работу практически без воздействия
на систему. Этот уровень уменьшения связанности является одним из наиболее
сильных преимуществ паттерна медиатор, который я вам предлагаю использовать.

Посмотрим на преимущества медиатора:

Уменьшает связывание модулей путем добавления посредника в роли центрольного
элемента управления. Это позволяет модулям отправлять и слушать сообщения
не затрагивая остальной части системы. Сообщения могут быть обработаны любым
количеством модулей сразу. 

Обычно это позволяет гораздо проще добавлять или удалять функциональность
в системах со слабым связыванием кода.

И недостатки:

По причине добавления медиатора, модулям придется всегда взаимодействовать
не напрямую. Также использование медиатора приводит к совсем небольшому падению
производительности из-за слабой связанности. Достаточно трудно установить
поведение системы исключительно на основе трансляции событий. В конце дня, 
системы с тесной связанностью могут вызывать различные боли, и уменьшение
связанности является одним из решений этих проблем.


**Пример:** возможная имплементация паттерна «медиатор» на основе работы [@rpflorence][8]

{% highlight javascript %}
var mediator = (function(){
    var subscribe = function(channel, fn){
        if (!mediator.channels[channel]) mediator.channels[channel] = [];
        mediator.channels[channel].push({ context: this, callback: fn });
        return this;
    },

    publish = function(channel){
        if (!mediator.channels[channel]) return false;
        var args = Array.prototype.slice.call(arguments, 1);
        for (var i = 0, l = mediator.channels[channel].length; i 
{% endhighlight %}


**Пример:** А это два примера использования реализации, которую мы определили
выше. Это эффективное управление публикацией и подпиской:

{% highlight javascript %}
//Pub/sub on a centralized mediator

mediator.name = "tim";
mediator.subscribe('nameChange', function(arg){
    console.log(this.name);
    this.name = arg;
    console.log(this.name);
});

mediator.publish('nameChange', 'david'); //tim, david


//Pub/sub via third party mediator

var obj = { name: 'sam' };
mediator.installTo(obj);
obj.subscribe('nameChange', function(arg){
    console.log(this.name);
    this.name = arg;
    console.log(this.name);
});

obj.publish('nameChange', 'john'); //sam, john
{% endhighlight %}

{:class="message"}
**Ссылки по теме:**  
Stoyan Stefanov - Page 168, JavaScript Patterns  
[HB Stone - JavaScript Design Patterns: Mediator][1]  
[NVince Huston - The Mediator Pattern (not specific to JavaScript, but a concise)][2]  


[1]: http://arguments.callee.info/2009/05/18/javascript-design-patterns--mediator/
[2]: http://www.vincehuston.org/dp/mediator.html

[7]: /assets/img/chart4a.jpg
[8]: https://github.com/rpflorence