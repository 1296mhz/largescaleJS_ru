<!-- ### Паттерн «Медиатор» -->

Объяснить, что представляет собой паттерн «медиатор» достаточно просто на примере
следующей аналогии — представьте себе контроль траффика в аэропорте: все решения
о том, какие самолеты могут взлетать или садиться, принимает диспетчер. Для этого,
все сообщения, исходящие от самолетов, поступают в башню управления, вместо того,
чтобы пересылаться между самолетами напрямую. Такой централизованный контроллер —
это и есть ключ к успеху нашей системы. Это и есть «медиатор».

{:.message}
Медиатор применяется в системах, где взаимодействие между модулями может быть
весьма сложными, но, с другой стороны, **хорошо определенными**. Если вы полагаете,
что связи между модулями вашей системы будут постоянно расти и усложняться, то, 
возможно, вам стоит добавить центральный элемент управления. Паттерн «медиатор»
отлично подходит для этой роли.

Медиатор выступает в качестве посредника в общении между различными модулями,
**инкапсулируя их взаимодействие**. Кроме того, этот шаблон проектирования,
предотвращая прямое взаимодействие различных компонентов системы, способствует
ослаюлению связей в коде. В нашей системе он так же помогает в решении проблем,
связанных с зависимостями модулей.

Какие еще преимущества существуют у «медиатора»? К примеру, медиатор позволяет
каждому модулю функционировать абсолютно независимо от других компонентов системы,
что приводит к большей гибкости системы. Если вам ранее уже приходилось
использовать паттерн «наблюдатель» в роли системы доставки событий между различными
частями в вашей системе, то вам не составит труда разобраться с медиатором.

Давайте посмотрим на модель взаимодействия модулей и медиатора:

![][7]

Мы можем смотреть на модули как на «издателя» и «медиатор», либо как на «издателя»
и «читателя». Модуль1 отправляет событие, сообщающее медиатору о том, что что-то
нужно сделать. Медиатор получает событие и сообщает модулям о том, что нужно 
выполнять действия необходимые для завершения полученной задачи. Модуль2
выполняет задачу, которую требовал модуль 1, и отправляет сообщение об этом
медиатору. Во время этого, модуль3 тоже запускается медиатором для логгироваия
всех сообщений, передаваемых обратно от медиатора.

Обратите внимание, что здесь нет прямого взаимодействию между модулями.
Если в модуле3 случится ошибка или он просто перестанет работать, то медатор,
гипотетически, может приостановить выполнение задач в других модулях,
перезапустить модуль3 и затем продолжить работу практически без воздействия
на систему. Этот уровень уменьшения связанности является одним из наиболее
сильных преимуществ паттерна медиатор, который я вам предлагаю использовать.

Посмотрим на преимущества медиатора:

Уменьшает связывание модулей путем добавления посредника в роли центрального
элемента управления. Это позволяет модулям отправлять и слушать сообщения
не затрагивая остальной части системы. Сообщения могут быть обработаны любым
количеством модулей сразу. 

Обычно это позволяет гораздо проще добавлять или удалять функциональность
в системах со слабым связыванием кода.

И недостатки:

По причине добавления медиатора, модулям придется всегда взаимодействовать
не напрямую. Также использование медиатора приводит к совсем небольшому падению
производительности из-за слабой связанности. Достаточно трудно установить
поведение системы исключительно на основе трансляции событий. В конце дня, 
системы с тесной связанностью могут вызывать различные боли, и уменьшение
связанности является одним из решений этих проблем.


**Пример:** возможная реализация паттерна «медиатор» на основе работы [@rpflorence][8]

{% highlight javascript %}
var mediator = (function(){
    var subscribe = function(channel, fn){
        if (!mediator.channels[channel]) mediator.channels[channel] = [];
        mediator.channels[channel].push({ context: this, callback: fn });
        return this;
    },

    publish = function(channel){
        if (!mediator.channels[channel]) return false;
        var args = Array.prototype.slice.call(arguments, 1);
        for (var i = 0, l = mediator.channels[channel].length; i 
{% endhighlight %}


**Пример:** А это два примера использования реализации, которую мы определили
выше. Это эффективное управление публикацией и подпиской:

{% highlight javascript %}
//Pub/sub on a centralized mediator

mediator.name = "tim";
mediator.subscribe('nameChange', function(arg){
    console.log(this.name);
    this.name = arg;
    console.log(this.name);
});

mediator.publish('nameChange', 'david'); //tim, david


//Pub/sub via third party mediator

var obj = { name: 'sam' };
mediator.installTo(obj);
obj.subscribe('nameChange', function(arg){
    console.log(this.name);
    this.name = arg;
    console.log(this.name);
});

obj.publish('nameChange', 'john'); //sam, john
{% endhighlight %}

{:class="message"}
**Ссылки по теме:**  
Stoyan Stefanov - Page 168, JavaScript Patterns  
[HB Stone - Шаблоны проектирования JavaScript: Медиатор][1]  
[NVince Huston - Шаблон Медиатора (не относится JavaScript, но кратко)][2]  


[1]: http://arguments.callee.info/2009/05/18/javascript-design-patterns--mediator/
[2]: http://www.vincehuston.org/dp/mediator.html

[7]: /assets/img/chart4a.jpg
[8]: https://github.com/rpflorence
