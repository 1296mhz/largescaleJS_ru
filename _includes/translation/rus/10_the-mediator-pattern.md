<!-- ### Паттерн «Медиатор» -->

Объяснить, что представляет собой паттерн «медиатор» достаточно просто на примере
следующей аналогии — представьте себе контроль траффика в аэропорте: все решения
о том, какие самолеты могут взлетать или садиться, принимает диспетчер. Для этого,
все сообщения, исходящие от самолетов, поступают в башню управления, вместо того,
чтобы пересылаться между самолетами напрямую. Такой централизованный контроллер —
это и есть ключ к успеху нашей системы. Это и есть «медиатор».

{:.message}
Медиатор применяется в системах, где взаимодействие между модулями может быть
весьма сложными, но **хорошо определенными**. Если вы полагаете,
что связи между модулями вашей системы будут постоянно расти и усложняться, то, 
возможно, вам стоит добавить центральный элемент управления. Паттерн «медиатор»
отлично подходит для этой роли.

Медиатор выступает в качестве посредника в общении между различными модулями,
**инкапсулируя их взаимодействие**. Кроме того, этот шаблон проектирования,
предотвращая прямое взаимодействие различных компонентов системы, способствует
ослаюлению связей в коде. В нашей системе он так же помогает в решении проблем,
связанных с зависимостями модулей.

Какие еще преимущества существуют у «медиатора»? К примеру, медиатор позволяет
каждому модулю функционировать абсолютно независимо от других компонентов системы,
что приводит к большей гибкости. Если вам ранее уже приходилось использовать
паттерн «наблюдатель» в роли системы доставки событий между различными частями
в вашей системе, то вам не составит труда разобраться с медиатором.

Давайте посмотрим на модель взаимодействия модулей и медиатора:

![][7]

Мы можем рассматривать модули, как «издателей», публикующих события. Медиатор же
является и «издателем» и «подписчиком» одновременно. `Module 1` посылает
сообщение, предполагающее некоторую реакцию, медиатору. Затем, медиатор, получив
сообщение, уведомляет другие модули об определенных действиях, которые необходимо
выполнить для завершения задачи. `Module 2` выполняет необходимые `Module 1`
действия, и сообщает о результате медиатору. В это же время, медиатор запускает
`Module 3` для логгирования приходящих в медиатор сообщений. 

Обратите внимание: здесь нет прямого взаимодействию между модулями. Если
в `Module 3` произойдет ошибка или он просто перестанет работать, то медатор,
теоретически, может приостановить выполнение задач в других модулях, затем
перезапустить `Module 3` и продолжить работу, практически, не влияя на работу
всей системы. Такая слабая связанность модулей является одним из самых
сильных преимуществ паттерна «медиатор», который я вам предлагаю использовать.

Посмотрим на его преимущества:

Уменьшает связывание модулей путем добавления посредника в роли центрального
элемента управления. Это позволяет модулям отправлять и слушать сообщения
не затрагивая остальной части системы. Сообщения могут быть обработаны любым
количеством модулей сразу. 

Обычно это позволяет гораздо проще добавлять или удалять функциональность
в системах со слабым связыванием кода.

И недостатки:

По причине добавления медиатора, модулям придется всегда взаимодействовать
не напрямую. Также использование медиатора приводит к совсем небольшому падению
производительности из-за слабой связанности. Достаточно трудно установить
поведение системы исключительно на основе трансляции событий. В конце дня, 
системы с тесной связанностью могут вызывать различные боли, и уменьшение
связанности является одним из решений этих проблем.


**Пример:** возможная реализация паттерна «медиатор» на основе работы [@rpflorence][8]

{% highlight javascript %}
var mediator = (function(){
    var subscribe = function(channel, fn){
        if (!mediator.channels[channel]) mediator.channels[channel] = [];
        mediator.channels[channel].push({ context: this, callback: fn });
        return this;
    },

    publish = function(channel){
        if (!mediator.channels[channel]) return false;
        var args = Array.prototype.slice.call(arguments, 1);
        for (var i = 0, l = mediator.channels[channel].length; i 
{% endhighlight %}


**Пример:** А это два примера использования реализации, которую мы определили
выше. Это эффективное управление публикацией и подпиской:

{% highlight javascript %}
//Pub/sub on a centralized mediator

mediator.name = "tim";
mediator.subscribe('nameChange', function(arg){
    console.log(this.name);
    this.name = arg;
    console.log(this.name);
});

mediator.publish('nameChange', 'david'); //tim, david


//Pub/sub via third party mediator

var obj = { name: 'sam' };
mediator.installTo(obj);
obj.subscribe('nameChange', function(arg){
    console.log(this.name);
    this.name = arg;
    console.log(this.name);
});

obj.publish('nameChange', 'john'); //sam, john
{% endhighlight %}

{:class="message"}
**Ссылки по теме:**  
Stoyan Stefanov - Page 168, JavaScript Patterns  
[HB Stone - Шаблоны проектирования JavaScript: Медиатор][1]  
[NVince Huston - Шаблон Медиатора (не относится JavaScript, но кратко)][2]  


[1]: http://arguments.callee.info/2009/05/18/javascript-design-patterns--mediator/
[2]: http://www.vincehuston.org/dp/mediator.html

[7]: /assets/img/chart4a.jpg
[8]: https://github.com/rpflorence
